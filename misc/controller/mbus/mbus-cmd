#!/usr/bin/perl -w
#
# Messbus-perl library (c) by Sven Anders <mbus@sven.anders.im> 2011
#  @copyright Copyright (c) 2011-2018, The volkszaehler.org project
#  @license https://www.gnu.org/licenses/gpl-3.0.txt GNU General Public License version 3

#
#  This file is part of volkzaehler.org
#
#  volkzaehler.org is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  any later version.
#
#  volkzaehler.org is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with volkszaehler.org. If not, see <http://www.gnu.org/licenses/>.
#

our $mbusPort="/dev/messbus"; # or /dev/ttyS0 ..
our $vzURL="http://host.domain/volkszaehler/middleware.php/";
our $vzOldFile="/var/lib/mbus/vzold";
our $mbusserial="/etc/mbus/serialno";
our $mbusBaudrate=2400;
our $lockfile="/var/lib/mbus/lockfile";
our %vzUuid;
use strict;
use mbus;
require "/etc/mbus/mbusconf.pm";
use LWP;
use Getopt::Long;
use LockFile::Simple qw(lock trylock unlock);

my $sqlout=0;
my $sqlrawout=0;
my $debug=0;
my $counter=0;
my $genserial=0;
my $verbose=0;
my $printmbusconf=0;
my $help=0;
my $cmd="mbus-cmd";
GetOptions ('debug' => \$debug,
	    'help' => \$help,
	    'sqlout' => \$sqlout,
	    'sqlrawout' => \$sqlrawout,
	    'verbose' => \$verbose,
	    'genserial' => \$genserial,
	    'print-mbusconf' => \$printmbusconf
    );


if ($help) {
    print "mbus-cmd [--help] [--debug] [--verbose] [--sqlout] [--sqlrawout] [--genserial] [--print-mbusconf]\n";
    print "\t--help  \tprint this help\n";
    print "\t--debug  \tdebug messages\n";
    print "\t--verbose\tverbose messages\n";
    print "\t--genserial\tgenerate $mbusserial file, find new mbus clients\n";
    print "\t--sqlout\tprint insert statements, which can be used for piplinig to mysql\n";
    print "\t--sqlrawout\tprint one insert statements for each client with the raw mbus telegram, which can be used for piplinig to mysql\n";
    print "\t--print-mbusconf\tuse this param to create a new mbusconf\n";
    exit;
}
if (-f $lockfile.".lock") {
    open(FILE,"<$lockfile".".lock") or die;
    my $pid=<FILE>;
    close(FILE);
    chop $pid;
    if (! (-d "/proc/$pid")) {
	warn("Removed stale lockfile $lockfile $pid");
	unlink($lockfile.".lock") or warn("can not remove lockfile");
    }

}
lock($lockfile) || die "can't lock $lockfile\n";
if ($genserial)  {

    my $PortObj=&initPort($mbusPort,$mbusBaudrate,$debug);
    my @liste=&findenummer("",$PortObj);
    print "speiche in $mbusserial";
    open(FILE,">$mbusserial") or die;
    foreach my $line (@liste) {
	print FILE "$line\n";
    }
    close(FILE);
    $PortObj->close();
    unlock($lockfile);
    exit;
}
(-f $mbusserial) or die("File $mbusserial not found, please generate with --genserial first!");
my $browser = LWP::UserAgent->new;
my %vzOld;
open(VZOLD,"<$vzOldFile");
my @lines=<VZOLD>;
foreach my $line (@lines) {
    chop $line;
    my ($uuid,$val)= split(/\t/,$line);
    $vzOld{$uuid}=$val;
}
close(VZOLD);

open(FILE,$mbusserial) or die;
my @serials=<FILE>;
close(FILE);

foreach my $serial (@serials)
{
 my $PortObj=&initPort($mbusPort,$mbusBaudrate,$debug);
 my $cfield=0x53;
 my $afield=0xFD;
 my $cifield=0x52;
 my $serialnum=&INTtoBCD($serial,4).chr(0xFF).chr(0xFF).chr(0xFF).chr(0xFF);
 &sendLongFrame($PortObj,$cfield,$afield,$cifield,$serialnum);
 my ($str,$okay)=&readAnswer($PortObj);
 ($okay==0) and die("Kollision bei Seriennummer:$serial");
 if ($okay!=1)  {
 warn("Zaehler nicht gefunden. Seriennummer:$serial");
} else {
 $cfield=0x5B;# REQ_UD2
 $afield=0xFD;
 &sendShortFrame($PortObj,$cfield,$afield);
 ($str,$okay)=&readAnswer($PortObj);
 my $ostr=&BCDtoINT(substr($str,7,4));
 if ($ostr == $serial ) {
 print "Gefunden: Seriennummer: $ostr\n" if $debug;
 my @chars=split(//,$str);
 if ($sqlrawout) {
     print "INSERT INTO rawdata SET serial=\"$ostr\",data=\"";
     foreach (@chars) {
 	 print "\\" ;
	 print ord($_);

     }
     print "\";\n";
 }
 my @datarr=&strToArray($str);
 my @labels=("vif","dif","value","unit","zweck","serial","valArt","count");

 my $pos=0;
 my %foundZaehlerStr;
 foreach my $arr (@datarr)
 {
     my ($vif,$dif,$value,$unit,$zweck,$serial,$valArt,$count)=@$arr;
     my $zaehlerStr=$serial."-".$zweck;
     my $zcount="";
     while (defined($foundZaehlerStr{$zaehlerStr.$zcount})) {
	 if ($zcount eq "") {
	     $zcount=1;
	 }
	 $zcount++;
     }
     $zaehlerStr.=$zcount;
     $foundZaehlerStr{$zaehlerStr}=1;
     if (defined($vzUuid{$zaehlerStr})) {
	 my $uuid=$vzUuid{$zaehlerStr};
	 if ($uuid ne "") {
	     my $sendval;
	     if (($zweck eq "Heizenergie") || ($zweck eq "Volumen")) {
		 if (defined($vzOld{$uuid})) {
		     $sendval=sprintf("%0.3f",($value-$vzOld{$uuid}));
		     if ($sendval<0.001) {
			 $sendval=undef;
		     }
		 }
		 $vzOld{$uuid}=$value;
	     } else {
		 $sendval=$value;
	     }
	     if (defined($sendval)) {
		 print "Sending POST ".$vzURL."data/".$uuid.".json  (value=$sendval)\n" if ($verbose);
		 my $response =$browser->post(($vzURL."data/".$uuid.".json"),[
					      "value" => $sendval
					      ]);
		 if (! $response->is_success) {
		     warn "$vzURL $uuid error: ", $response->status_line;
		 }
	     } else {
		 print "NOT Sending POST ".$vzURL."data/".$uuid.".json  (value not changed)\n" if ($verbose);
	     }

	 }
     } elsif ($printmbusconf) {
	 print "\$vzUuid{\"$zaehlerStr\"\}=\"\";# ($value) \n";
     }
     print "INSERT INTO zaehler SET pos=\"$pos\"," if $sqlout;
     my $i=0;
     foreach (@$arr) {
     	if ($i>0)
	{
	  print "," if $sqlout;
	}
     	print "$labels[$i]=\"$_\"" if $sqlout;
	$i++;
     }
     $pos++;
     print ";\n" if $sqlout;
 }
} else {
    warn "Serial mismatch: $ostr != $serial";
}
}

$PortObj->close();
}

open(VZOLD,">$vzOldFile");
foreach my $key (keys %vzOld) {
    print VZOLD "$key\t$vzOld{$key}\n";
}
close(VZOLD);
unlock($lockfile);
