#!/usr/bin/python
#-*- coding:utf8 -*-
#
# @author Peer Janssen
# @author Justin Otherguy <justin@justinotherguy.org>
# @author Henrik Wellschmidt <w3llschmidt@gmail.com>
# @copyright Copyright (c) 2011, The volkszaehler.org project
# @package default
# @license http://opensource.org/licenses/gpl-license.php GNU Public License
#
#/*
#* This file is part of volkzaehler.org
#*
#* volkzaehler.org is free software: you can redistribute it and/or modify
#* it under the terms of the GNU General Public License as published by
#* the Free Software Foundation, either version 3 of the License, or
#* any later version.
#*
#* volkzaehler.org is distributed in the hope that it will be useful,
#* but WITHOUT ANY WARRANTY; without even the implied warranty of
#* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#* GNU General Public License for more details.
#*
#* You should have received a copy of the GNU General Public License
#* along with volkszaehler.org. If not, see <http://www.gnu.org/licenses/>.
#*/

# CCALERT is intended to operate as a cronjob and monitors the cost (current consumption) for a particular UUID 'Strommesser', 
# based on the configured costs of the channel and the consumption within the configured interval.

#----<config>-------------------------------------------------------------

# URL of the vz middleware

middleware = 'http://demo.volkszaehler.org/middleware.php/'

#----</config>------------------------------------------------------------

tz_offset = 2 # h; CEST -> 2; CET -> 1; show me, how to improve this! :-)

#------------------------------------------------------------------------

import argparse

parser = argparse.ArgumentParser(
prog='CCALERT',
description='Configure CCALERT at the commandline ->',
epilog="CCALERT is intended to operate as a cronjob and monitors the cost (current consumption) for a particular UUID, based on the configured costs of the channel 'Strommesser' and the consumption within the interval.")

parser.add_argument("-u",dest="uuid", required=True, help="Enter your 'Strommesser' UUID here!")
parser.add_argument("-c",dest="costs", type=float, default=0, help="Cost limit that will cause a alert (default 1.50)")
parser.add_argument("-i",dest="interval",  type=int, default=86400, help="Monitoring interval in seconds (default 86400 = 24h)")

args = parser.parse_args()

uuid = args.uuid 
maximum_value = args.costs
interval = args.interval

uuidstring = str(uuid)

import datetime

# convert timestamp into volkszaehler format
def timestamp2vz_format(ts):
  tz_delta = datetime.timedelta(seconds=tz_offset*3600) #UTC offset and adjustment for daylight saving time (sutraction in seconds)
  dt = ts - datetime.datetime(1970, 1, 1, 0, 0) - tz_delta
  Timestamp = str(dt.days*86400 + dt.seconds) + str(dt.microseconds).zfill(6)[:-3]
  return Timestamp

now = datetime.datetime.now()
past = now  - datetime.timedelta(seconds=interval)
intervalstart = timestamp2vz_format(past)

#------------------------------------------------------------------------

import urllib2
import json

url_cost = middleware
url_cost += 'channel/'
url_cost += uuid
url_cost += '.json'

cost = urllib2.urlopen(url_cost).read()
json_decoded = json.loads(cost)
strompreis = json_decoded['entity']['cost']

url_data = middleware
url_data += 'data/'
url_data += uuid
url_data += '.json?from='
url_data += intervalstart
	
result = urllib2.urlopen(url_data).read() 
json_decoded = json.loads(result)
number_of_values = json_decoded['data']['rows']
average = json_decoded['data']['average']
consumption = json_decoded['data']['consumption']

kWh = consumption / 1000
kosten = consumption * strompreis

if kosten > maximum_value:
	print '~%.2f kWh (%.2f EUR)' % (kWh, kosten)
